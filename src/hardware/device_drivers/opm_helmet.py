"""
NIBIB OPM Helmet Driver with Matrix Coil Compensation
=====================================

This module implements the driver for the NIBIB OPM (Optically Pumped Magnetometer)
helmet system with integrated matrix coil active magnetic shielding.

Based on the research from Holmes et al. (2023) "Enabling ambulatory movement in
wearable magnetoencephalography with matrix coil active magnetic shielding"
https://pmc.ncbi.nlm.nih.gov/articles/PMC10465235/

Features:
- 48 square unit coils arranged on two planes for active shielding
- Real-time field compensation with 25ms latency (40Hz update rate)
- Triaxial OPM sensor support (QuSpin Zero Field Magnetometers)
- Optical tracking integration for 6-DOF helmet positioning
- Spherical harmonic field modeling for precise compensation
- Sub-nanotesla field control for optimal OPM operation

Author: Brain-Forge Development Team
Date: 2025-01-28
License: MIT
"""

import asyncio
import logging
import time
from dataclasses import dataclass
from typing import Any, Dict, List

import numpy as np
from scipy.linalg import pinv

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class OPMSensorConfig:
    """Configuration for individual OPM sensor"""
    sensor_id: str
    position: np.ndarray  # 3D position in helmet frame
    orientation: np.ndarray  # 3D orientation vector
    sensitivity: float = 15e-15  # Tesla/√Hz - typical QuSpin sensitivity
    dynamic_range: float = 1.5e-9  # ±1.5 nT operational range
    sample_rate: int = 1200  # Hz


@dataclass
class MatrixCoilConfig:
    """Configuration for matrix coil system"""
    coil_positions: np.ndarray  # 48 x 3 array of coil positions
    plane_separation: float = 1.7  # meters
    coil_resistance: np.ndarray  # 48-element array of coil resistances
    max_current: float = 0.045  # Amperes - max current per coil
    update_rate: float = 40.0  # Hz - field compensation update rate
    feedback_gain: float = 0.4  # Feedback controller gain


@dataclass
class HelmetPosition:
    """6-DOF helmet position from optical tracking"""
    position: np.ndarray  # 3D translation [x, y, z]
    rotation: np.ndarray  # 3x3 rotation matrix
    timestamp: float
    quality: float  # Tracking quality indicator


class SphericalHarmonics:
    """
    Spherical harmonic field modeling for OPM-MEG systems

    Implements uniform field and field gradient compensation using
    8-component spherical harmonic basis (3 uniform + 5 gradients)
    """

    def __init__(self):
        self.n_components = 8  # 3 uniform fields + 5 linear gradients

    def compute_field_model(self, sensor_positions: np.ndarray,
                          center: np.ndarray) -> np.ndarray:
        """
        Compute spherical harmonic field model matrix

        Args:
            sensor_positions: N x 3 array of sensor positions
            center: 3-element center position for harmonic expansion

        Returns:
            N x 8 matrix A where A @ coeffs gives field at each sensor
        """
        n_sensors = sensor_positions.shape[0]
        A = np.zeros((n_sensors, self.n_components))

        # Relative positions
        rel_pos = sensor_positions - center
        x, y, z = rel_pos[:, 0], rel_pos[:, 1], rel_pos[:, 2]

        # Uniform field components (first 3 components)
        A[:, 0] = 1.0  # Bx uniform
        A[:, 1] = 1.0  # By uniform
        A[:, 2] = 1.0  # Bz uniform

        # Linear gradient components (next 5 components)
        A[:, 3] = x  # dBz/dx
        A[:, 4] = y  # dBz/dy
        A[:, 5] = z  # dBz/dz
        A[:, 6] = x  # dBx/dx - dBy/dy
        A[:, 7] = y  # dBx/dy + dBy/dx

        return A


class MatrixCoilController:
    """
    Active magnetic shielding using 48-coil matrix system

    Implements real-time field compensation based on OPM measurements
    and optical tracking of helmet position.
    """

    def __init__(self, config: MatrixCoilConfig):
        self.config = config
        self.harmonics = SphericalHarmonics()
        self.is_active = False
        self.current_voltages = np.zeros(48)
        self.coil_efficiencies = None

    async def initialize(self):
        """Initialize matrix coil system"""
        logger.info("Initializing matrix coil controller...")

        # Calculate coil efficiency matrix for current helmet position
        await self._calibrate_coil_efficiencies()

        # Initialize DAC outputs
        self.current_voltages = np.zeros(48)
        logger.info("Matrix coil controller initialized")

    async def _calibrate_coil_efficiencies(self):
        """
        Calculate coil efficiency matrix B_coil

        B_coil[i,j] = field component i generated by unit current in coil j
        """
        # This would normally involve Biot-Savart calculations
        # For now, use placeholder based on coil geometry
        self.coil_efficiencies = np.random.randn(8, 48) * 1e-6
        logger.info("Coil efficiencies calibrated")

    def update_field_compensation(self, field_changes: np.ndarray,
                                sensor_positions: np.ndarray,
                                helmet_center: np.ndarray) -> np.ndarray:
        """
        Calculate required coil currents for field compensation

        Args:
            field_changes: N-element array of field changes at each sensor
            sensor_positions: N x 3 array of sensor positions
            helmet_center: 3-element helmet center position

        Returns:
            48-element array of required coil voltages
        """
        # Compute field model matrix A
        A = self.harmonics.compute_field_model(sensor_positions, helmet_center)

        # Solve for spherical harmonic coefficients
        A_pinv = pinv(A)
        coefficients = A_pinv @ field_changes

        # Calculate required coil currents
        B_coil_pinv = pinv(self.coil_efficiencies)
        required_currents = -B_coil_pinv @ coefficients  # Negative for compensation

        # Apply current limits
        max_current = self.config.max_current
        required_currents = np.clip(required_currents, -max_current, max_current)

        # Convert to voltages using coil resistances
        required_voltages = required_currents * self.config.coil_resistance

        # Apply feedback gain
        voltage_update = self.config.feedback_gain * required_voltages

        # Update with gain to prevent instability
        self.current_voltages += voltage_update

        # Apply voltage limits (±10V DAC range)
        self.current_voltages = np.clip(self.current_voltages, -10.0, 10.0)

        return self.current_voltages


class OPMHelmetDriver:
    """
    Main driver class for NIBIB OPM helmet system

    Integrates:
    - Multiple triaxial OPM sensors (QuSpin)
    - Matrix coil active shielding
    - Optical tracking system
    - Real-time field compensation
    """

    def __init__(self, sensors: List[OPMSensorConfig],
                 matrix_config: MatrixCoilConfig):
        self.sensors = sensors
        self.matrix_config = matrix_config
        self.matrix_controller = MatrixCoilController(matrix_config)

        # Data buffers
        self.sensor_data = {}
        self.helmet_position = None
        self.baseline_fields = None
        self.compensation_active = False

        # Timing
        self.last_compensation_time = 0
        self.compensation_interval = 1.0 / matrix_config.update_rate

        # Statistics
        self.stats = {
            'compensation_updates': 0,
            'max_field_change': 0.0,
            'avg_compensation_latency': 0.0
        }

    async def initialize(self):
        """Initialize OPM helmet system"""
        logger.info("Initializing OPM helmet system...")

        # Initialize matrix coil controller
        await self.matrix_controller.initialize()

        # Initialize sensor data buffers
        for sensor in self.sensors:
            self.sensor_data[sensor.sensor_id] = {
                'field_data': [],
                'timestamps': [],
                'last_sample': None
            }

        # Establish baseline field measurements
        await self._establish_baseline()

        logger.info(f"OPM helmet initialized with {len(self.sensors)} sensors")

    async def _establish_baseline(self):
        """Establish baseline field measurements for each sensor"""
        logger.info("Establishing baseline field measurements...")

        # Collect 30 samples (25ms at 1200 Hz) for baseline
        baseline_samples = []
        for _ in range(30):
            sample = await self._read_sensor_sample()
            baseline_samples.append(sample)
            await asyncio.sleep(1.0 / 1200)  # 1200 Hz sampling

        # Calculate baseline means
        baseline_array = np.array(baseline_samples)
        self.baseline_fields = np.mean(baseline_array, axis=0)

        logger.info(f"Baseline established: {self.baseline_fields[:5]}... nT")

    async def _read_sensor_sample(self) -> np.ndarray:
        """Read current field measurements from all sensors"""
        # Simulate sensor readings - replace with actual hardware interface
        n_sensors = len(self.sensors)

        # Add some realistic noise and drift
        base_field = 2e-9  # 2 nT baseline
        noise = np.random.normal(0, 15e-15, n_sensors)  # 15 fT/√Hz noise
        drift = 1e-12 * np.sin(time.time() * 0.1)  # Slow drift

        return base_field + noise + drift

    def update_helmet_position(self, position: HelmetPosition):
        """Update helmet position from optical tracking system"""
        self.helmet_position = position

        # Update sensor positions based on helmet movement
        self._update_sensor_positions()

    def _update_sensor_positions(self):
        """Update sensor positions based on current helmet pose"""
        if self.helmet_position is None:
            return

        # Transform sensor positions to world coordinates
        helmet_rotation = self.helmet_position.rotation
        helmet_translation = self.helmet_position.position

        for sensor in self.sensors:
            # Transform from helmet frame to world frame
            world_pos = helmet_rotation @ sensor.position + helmet_translation
            # Store transformed position (could cache this)

    async def start_compensation(self):
        """Start active field compensation"""
        if self.compensation_active:
            return

        logger.info("Starting active field compensation...")
        self.compensation_active = True

        # Start compensation loop
        asyncio.create_task(self._compensation_loop())

    async def stop_compensation(self):
        """Stop active field compensation"""
        logger.info("Stopping active field compensation...")
        self.compensation_active = False

        # Reset coil voltages to zero
        self.matrix_controller.current_voltages = np.zeros(48)

    async def _compensation_loop(self):
        """Main field compensation loop running at 40 Hz"""
        while self.compensation_active:
            start_time = time.time()

            try:
                # Read current sensor data
                current_fields = await self._read_sensor_sample()

                # Calculate field changes relative to baseline
                if self.baseline_fields is not None:
                    field_changes = current_fields - self.baseline_fields

                    # Get current sensor positions
                    sensor_positions = np.array([s.position for s in self.sensors])
                    helmet_center = np.zeros(3)  # Center of helmet

                    if self.helmet_position is not None:
                        helmet_center = self.helmet_position.position

                    # Update compensation
                    voltages = self.matrix_controller.update_field_compensation(
                        field_changes, sensor_positions, helmet_center
                    )

                    # Apply voltages to DACs (simulated)
                    await self._apply_coil_voltages(voltages)

                    # Update statistics
                    self.stats['compensation_updates'] += 1
                    max_change = np.max(np.abs(field_changes))
                    self.stats['max_field_change'] = max(
                        self.stats['max_field_change'], max_change
                    )

                # Calculate actual latency
                processing_time = time.time() - start_time
                self.stats['avg_compensation_latency'] = (
                    0.9 * self.stats['avg_compensation_latency'] +
                    0.1 * processing_time
                )

                # Wait for next update cycle (40 Hz)
                sleep_time = max(0, self.compensation_interval - processing_time)
                await asyncio.sleep(sleep_time)

            except Exception as e:
                logger.error(f"Error in compensation loop: {e}")
                await asyncio.sleep(0.001)  # Brief pause before retry

    async def _apply_coil_voltages(self, voltages: np.ndarray):
        """Apply voltages to matrix coil DACs"""
        # This would interface with actual DAQ hardware
        # For now, just log maximum voltage being applied
        max_voltage = np.max(np.abs(voltages))
        if max_voltage > 0.1:  # Only log significant voltages
            logger.debug(f"Applying coil voltages, max: {max_voltage:.3f}V")

    async def acquire_data(self, duration: float) -> Dict[str, Any]:
        """
        Acquire synchronized data for specified duration

        Args:
            duration: Acquisition time in seconds

        Returns:
            Dictionary containing synchronized sensor data and metadata
        """
        logger.info(f"Starting data acquisition for {duration:.1f} seconds...")

        start_time = time.time()
        data_buffer = []
        timestamps = []

        # Start compensation if not already active
        if not self.compensation_active:
            await self.start_compensation()

        # Acquisition loop at sensor sample rate
        sample_interval = 1.0 / 1200  # 1200 Hz

        while (time.time() - start_time) < duration:
            timestamp = time.time()

            # Read sensor data
            sensor_data = await self._read_sensor_sample()

            # Store data with timestamp
            data_buffer.append(sensor_data)
            timestamps.append(timestamp)

            # Wait for next sample
            await asyncio.sleep(sample_interval)

        # Package results
        result = {
            'sensor_data': np.array(data_buffer),
            'timestamps': np.array(timestamps),
            'sensor_configs': self.sensors,
            'helmet_positions': [],  # Would store tracking data
            'compensation_stats': self.stats.copy(),
            'sample_rate': 1200,
            'duration': duration
        }

        logger.info(f"Data acquisition complete: {len(data_buffer)} samples")
        return result

    def get_system_status(self) -> Dict[str, Any]:
        """Get current system status"""
        return {
            'sensors_active': len(self.sensors),
            'compensation_active': self.compensation_active,
            'matrix_coil_status': 'operational',
            'helmet_tracking': self.helmet_position is not None,
            'compensation_rate': f"{self.matrix_config.update_rate:.1f} Hz",
            'avg_latency_ms': self.stats['avg_compensation_latency'] * 1000,
            'max_field_change_pT': self.stats['max_field_change'] * 1e12,
            'total_updates': self.stats['compensation_updates']
        }


# Example usage and testing
async def main():
    """Example usage of OPM helmet system"""

    # Configure sensors (simplified - would load from config file)
    sensors = []
    for i in range(15):  # 15 triaxial sensors = 45 channels
        sensor = OPMSensorConfig(
            sensor_id=f"OPM_{i:02d}",
            position=np.random.randn(3) * 0.1,  # Random positions around helmet
            orientation=np.array([0, 0, 1])  # All pointing outward for simplicity
        )
        sensors.append(sensor)

    # Configure matrix coil system
    matrix_config = MatrixCoilConfig(
        coil_positions=np.random.randn(48, 3),  # Would be actual coil positions
        plane_separation=1.7,
        coil_resistance=np.full(48, 2.0),  # 2Ω per coil
        max_current=0.045,
        update_rate=40.0,
        feedback_gain=0.4
    )

    # Create and initialize system
    helmet = OPMHelmetDriver(sensors, matrix_config)
    await helmet.initialize()

    # Simulate helmet position update
    position = HelmetPosition(
        position=np.array([0.15, -0.24, 0.18]),  # Off-center as in paper
        rotation=np.eye(3),
        timestamp=time.time(),
        quality=0.95
    )
    helmet.update_helmet_position(position)

    # Start compensation and acquire data
    await helmet.start_compensation()

    # Simulate some movement and data acquisition
    logger.info("Simulating data acquisition with movement...")
    data = await helmet.acquire_data(5.0)  # 5 seconds of data

    # Print results
    status = helmet.get_system_status()
    logger.info("System Status:")
    for key, value in status.items():
        logger.info(f"  {key}: {value}")

    logger.info(f"Acquired data shape: {data['sensor_data'].shape}")
    logger.info(f"Sample rate: {data['sample_rate']} Hz")

    await helmet.stop_compensation()


if __name__ == "__main__":
    asyncio.run(main())
    asyncio.run(main())
